<!DOCTYPE html>
<html>
<title>Vulkan Ray Tracing Tutorial</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
<link rel="stylesheet" href="style.css">
<style>
  body,h1,h2,h3,h4,h5 {font-family: "Raleway", sans-serif}
</style>
<body class="w3-light-grey">

<div class="w3-content" style="max-width:1400px">

<header class="w3-container w3-center w3-padding-32"> 
  <h1><b>Vulkan Ray Tracing Tutorial (with Minimal Abstraction)</b></h1>
  <p>By William Lew</p>
</header>

<div class="w3-row">

<div class="w3-col">
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h2><b>Introduction to the Tutorial</b></h2>
      <div class="row">
        <div class="column">
          <img style="border: 5px solid #555; width: 100%;" src="res/a.png">
        </div>
        <div class="column">
          <img style="border: 5px solid #555; width: 100%;" src="res/b.png">
        </div>
      </div>
      <h4><b>Prerequisites and Resources</b></h4>
      <p>
      	A basic understanding of Vulkan is recommended; this tutorial focuses specifically on the <b>VK_KHR_ray_tracing</b> extension for Vulkan. The tutorial will not cover in depth the general topics of Vulkan, but will describe all the procedures involving ray tracing; there are many great online resources for learning Vulkan so rather than rewriting their information, I will just provide the links to their websites.
        <br>
        <a href="https://vulkan-tutorial.com/">https://vulkan-tutorial.com/</a>
        <br><br>
        Unlike the other tutorials on the ray tracing extension, this tutorial implements the ray tracing extension in a single file with minimal abstraction. The other tutorials do an amazing job of encapsulating procedures, but sometimes it is easier to learn from a minimal implementation. 
        <br><br>
        Here are two amazing resources for Vulkan ray tracing:
        <br>
        <a href="https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/">https://nvpro-samples.github.io/vk_raytracing_tutorial_KHR/</a>
        <br>
        <a href="https://github.com/SaschaWillems/Vulkan/blob/master/examples/raytracingbasic/raytracingbasic.cpp">https://github.com/SaschaWillems/Vulkan/blob/master/examples/raytracingbasic/raytracingbasic.cpp</a>
        <br><br>
        Here is the link to the Github repository for the tutorial:
        <br>
        <a href="https://github.com/WilliamLewww/vulkan_ray_tracing_minimal_abstraction">https://github.com/WilliamLewww/vulkan_ray_tracing_minimal_abstraction</a>
      </p>
      <h4><b>Tutorial Structure</b></h4>
      <p>
        There are two parts of this tutorial that will describe a different method for Vulkan ray tracing. You should view the code on github while reading the tutorial; the majority of the code in this tutorial is heavily truncated for simplicity.
        <br><br>
        The first approach is to use the <b>ray tracing pipeline</b> in which we will launch rays from the the <b>ray generation shader</b> and depending on the intersection, either a <b>ray hit shader</b> or a <b>ray miss shader</b> will handle the ray. This is a pure ray tracing approach in which the graphics pipeline is completely ignored; instead of using the graphics pipeline to rasterize primitives, the ray tracing pipeline will launch rays for each pixel of an image and resolve the pixel's color from the ray's payload.
        <br><br>
        The second approach is to use <b>ray querying</b> in which we can launch rays from the shader stages in the graphics pipeline. This is a hybrid approach because the graphics pipeline is still involved. For example, we can have a hybrid renderer by rasterizing primitives and launching rays from the rasterized primitives. In the <b>fragment shader</b>, we can grab the interpolated position of the rasterized primitive and then cast a ray from the position to test for shadows.
      </p>
    </div>

    <div class="w3-container">
      <h2><b>Setting up the Environment</b></h2>
      <h4><b>Driver Compatibility</b></h4>
      <p>
        Currently (9 September 2020), the VK_KHR_ray_tracing extension is only available with the Vulkan beta drivers. <b>Even if your device is compatible with the extension, your driver may not have the extension available</b>.
        <br><br>
        Here is the link to download the Vulkan beta drivers:
        <br>
        <a href="https://developer.nvidia.com/vulkan-driver">https://developer.nvidia.com/vulkan-driver</a>
      </p>
      <h4><b>Device Compatibility</b></h4>
      <p>
        After installing the Vulkan SDK, you must check to see if the VK_KHR_ray_tracing extension is compatible with your GPU. To see if the extension is available with your device, you can use the <b>vulkaninfo</b> program. The <b>vulkaninfo</b> program may not display VK_KHR_ray_tracing if you are using incompatible drivers.
        <br><br>
        Here is an example of using the <b>vulkaninfo</b> program in linux:
        <br>
        <div class="w3-card-4 w3-margin w3-white">
          <p>
            <b>$ vulkaninfo | grep VK_KHR_ray_tracing</b>
            <br>
            ERROR: [Loader Message] Code 0 : /usr/lib32/amdvlk32.so: wrong ELF class: ELFCLASS32
            <br>
            <b>VK_KHR_ray_tracing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : extension revision 8</b>
            <br>
            <b>VK_KHR_ray_tracing &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : extension revision 8</b>
          </p>
        </div>
        Windows has a graphical <b>vulkaninfo</b> program that is installed with the Vulkan SDK. Navigate through the menus and check if the device extension <b>VK_KHR_ray_tracing</b> is available.
      </p>
    </div>
  </div>
  <hr>
</div>

<div class="w3-col">
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h2><b>Ray Tracing Pipeline</b></h2>
      <h4><b>Program Procedure</b></h4>
      <p>
        We first need to make sure we include the correct headers. Since we are using a <b>beta extension</b> we need to define <b>VK_ENABLE_BETA_EXTENSIONS</b>. We are also using <b>tinyobjloader-c</b> to load <b>.obj</b> models so we also need to include its header file.
        <br>
        <b>(main.c: 1)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">#define VK_ENABLE_BETA_EXTENSIONS
#include &lt;vulkan/vulkan.h&gt;
#include &lt;GLFW/glfw3.h&gt;

#define TINYOBJ_LOADER_C_IMPLEMENTATION
#include "tinyobj_loader_c.h"
</code></pre>
        </div>
        Let's take a look at the main function.
        <br>
        <b>(main.c: 1936)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">int main(void) {
  struct VulkanApplication* app = (struct VulkanApplication*)malloc(sizeof(struct VulkanApplication));
  struct Scene* scene = (struct Scene*)malloc(sizeof(struct Scene));

  struct Camera* camera = &(struct Camera) {
    .position = {
      0, 0, 0, 1
    },
    .right = {
      1, 0, 0, 1
    },
    .up = {
      0, 1, 0, 1
    },
    .forward = {
      0, 0, 1, 1
    },

    .frameCount = 0,
  };

  initializeScene(scene, "res/cube_scene.obj");

  initializeVulkanContext(app);
  pickPhysicalDevice(app);
  createLogicalConnection(app);
  createSwapchain(app);  
  createCommandPool(app);
  createVertexBuffer(app, scene);
  createIndexBuffer(app, scene);
  createMaterialBuffers(app, scene);
  createTextures(app);

  createAccelerationStructure(app, scene);
  bindAccelerationStructure(app);
  buildAccelerationStructure(app, scene);
  createTopLevelAccelerationStructure(app);

  createUniformBuffer(app);
  createDescriptorSets(app);

  createRayTracePipeline(app);
  createShaderBindingTable(app);
  createCommandBuffers(app);

  createSynchronizationObjects(app);

  runMainLoop(app, camera);

  cleanUp(app, scene);

  free(app);
  free(scene);
  
  return 0;
}
</code></pre>
        </div>
        <br>
        <h4><b>Allocating Structure Memory and Importing Scene</b></h4>
        First, the memory for a <b>VulkanApplication</b> structure is allocated. The <b>VulkanApplication</b> structure contains all the required data for our application (E.g.: vertex buffers, images, ray tracing pipeline, etc...).
        <br>
        <b>(main.c: 1937)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">struct VulkanApplication* app = (struct VulkanApplication*)malloc(sizeof(struct VulkanApplication));</code></pre>
        </div>
        Then, the memory for a <b>Scene</b> structure is allocated to store the data from an <b>.obj</b> file.
        <br>
        <b>(main.c: 1938)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">struct Scene* scene = (struct Scene*)malloc(sizeof(struct Scene));</code></pre>
        </div>
        The memory for a <b>Camera</b> structure is allocated so the data can be easily copied to the uniform buffer that is later used in the shaders.
        <br>
        <b>(main.c: 1940)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">struct Camera* camera = &(struct Camera) {
  .position = {
    0, 0, 0, 1
  },
  .right = {
    1, 0, 0, 1
  },
  .up = {
    0, 1, 0, 1
  },
  .forward = {
    0, 0, 1, 1
  },

  .frameCount = 0,
};
</code></pre>
        </div>
        The <b>initializeScene</b> function is called with the <b>scene</b> we recently allocated and a string that contains the path to an <b>.obj</b> file. The function calls the <b>tinyobjloader-c</b> functions which in turn store the <b>.obj</b> mesh into the <b>scene</b>.
        <br>
        <b>(main.c: 1957)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">initializeScene(scene, "res/cube_scene.obj");</code></pre>
        </div>
        <br>
        <h4><b>Vulkan Setup</b></h4>
        <h6><b>Initialize Vulkan Context</b></h6>
        When initializing Vulkan, we must make sure to include the Vulkan instance extension that is required to use the VK_KHR_ray_tracing extension. In this case, we include the <b>VK_KHR_get_physical_device_properties2</b> extension to our array of instance extensions.
        <br>
        <b>(main.c: 287)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">extensionNames[glfwExtensionCount] = "VK_KHR_get_physical_device_properties2";</code></pre>
        </div>
        <h6><b>Pick Physical Device</b></h6>
        The code assumes that the only (or first) available device is compatible with the VK_KHR_ray_tracing extension. If you are using multiple devices, you might need to refactor the code to select the device that is compatible with the extension.
        <h6><b>Create Logical Connection</b></h6>
        Just like when initializing Vulkan, we must make sure to include the device extensions that are required to use the VK_KHR_ray_tracing extension. The extensions we will be using can be seen in the snippet below.
        <br>
        <b>(main.c: 397)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">deviceEnabledExtensionNames[0] = VK_KHR_SWAPCHAIN_EXTENSION_NAME;  
deviceEnabledExtensionNames[1] = "VK_KHR_ray_tracing";  
deviceEnabledExtensionNames[2] = "VK_KHR_get_memory_requirements2";
deviceEnabledExtensionNames[3] = "VK_EXT_descriptor_indexing";
deviceEnabledExtensionNames[4] = "VK_KHR_buffer_device_address";
deviceEnabledExtensionNames[5] = "VK_KHR_deferred_host_operations";
deviceEnabledExtensionNames[6] = "VK_KHR_pipeline_library";
deviceEnabledExtensionNames[7] = "VK_KHR_maintenance3";
</code></pre>
        </div>
        A compute queue must be initialized because we will later use it when building the acceleration structure.
        <br><br>
        We must also make sure the ray tracing features and a couple other sets of features are enabled. We will be using the <b>VkPhysicalDeviceBufferDeviceAddressFeatures</b> features to get the device address of the vertex buffer so we can pass it to the acceleration structure.
        <br>
        <b>(main.c: 431)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkPhysicalDeviceBufferDeviceAddressFeaturesEXT bufferDeviceAddressFeatures = {};
bufferDeviceAddressFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT;  
bufferDeviceAddressFeatures.bufferDeviceAddress = VK_TRUE;

VkPhysicalDeviceRayTracingFeaturesKHR rayTracingFeatures = {};
rayTracingFeatures.pNext = &bufferDeviceAddressFeatures;
rayTracingFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_FEATURES_KHR;
rayTracingFeatures.rayTracing = VK_TRUE;
rayTracingFeatures.rayQuery = VK_TRUE;
</code></pre>
        </div>
        <h6><b>Create Swapchain</b></h6>
        When creating the swapchain, the swapchain image usage flags must be set to both <b>VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</b> and <b>VK_IMAGE_USAGE_TRANSFER_DST_BIT</b>. The ray tracing shaders will write to a ray traced image, but we will need to copy that separate image to an image on the swap chain so we can present it to the window. If we do not specify <b>VK_IMAGE_USAGE_TRANSFER_DST_BIT</b> we will be unable to copy the ray traced image to the swap chain image.
        <br>
        <b>(main.c: 496)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">swapchainCreateInfo.imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT;</code></pre>
				</div>
				<h6><b>Create Command Pool</b></h6>
				No special changes need to be made to enable Vulkan ray tracing.
				<h6><b>Create Vertex Buffer</b></h6>
				In order to use the vertex buffer for the acceleration structure, we must enable the <b>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</b> usage flag when creating the buffer. This will allow us to pass the device address of the vertex buffer to the acceleration structure we will create later. The <b>scene</b> stores the vertices of the <b>.obj</b> file in a data member named <b>attributes</b> and all we need to do is copy the vertex data into the device buffer memory.
				<br>
				<b>(main.c: 546)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">void* positionData;
vkMapMemory(app->logicalDevice, positionStagingBufferMemory, 0, positionBufferSize, 0, &positionData);
memcpy(positionData, scene->attributes.vertices, positionBufferSize);
vkUnmapMemory(app->logicalDevice, positionStagingBufferMemory);
</code></pre>
				</div>
				<h6><b>Create Index Buffer</b></h6>
				Just like when creating the vertex buffer, we need to enable the <b>VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT</b> usage flag when creating the buffer. The <b>scene</b> also holds the index buffer data so we can just copy the data into the buffer. Since we are only using the position index in this example, we just need to extract the position indices from the <b>scene</b>.
				<br>
				<b>(main.c: 562)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">uint32_t* positionIndices = (uint32_t*)malloc(bufferSize);
for (int x = 0; x < scene->attributes.num_faces; x++) {
  positionIndices[x] = scene->attributes.faces[x].v_idx;
}
</code></pre>
				</div>
				<h6><b>Create Materials Buffer</b></h6>
				To determine the color, reflectance, emission, etc... of a surface, we will copy the materials from the <b>.mtl</b> file into a material buffer so we can use the surface materials in the shaders. The <b>tinyobjloader-c</b> automatically parses the <b>.mtl</b> file when parsing a <b>.obj</b> file so no extra steps need to be taken.
				<br>
				<b>(main.c: 607)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">struct Material* materials = (struct Material*)malloc(materialBufferSize);
for (int x = 0; x < scene->numMaterials; x++) {
  memcpy(materials[x].ambient, scene->materials[x].ambient, sizeof(float) * 3);
  memcpy(materials[x].diffuse, scene->materials[x].diffuse, sizeof(float) * 3);
  memcpy(materials[x].specular, scene->materials[x].specular, sizeof(float) * 3);
  memcpy(materials[x].emission, scene->materials[x].emission, sizeof(float) * 3);
}
</code></pre>
				</div>
				<h6><b>Create Textures</b></h6>
				We create a ray traced image that will be used to store the ray's final color value. 
				<br><br>
				To present or display the image, we will copy the ray traced image to the swapchain. We need to enable the <b>VK_IMAGE_USAGE_TRANSFER_SRC_BIT</b> usage flag so it can be used as a source of a copy function. The shaders will read and write to the ray traced image so we need to add <b>VK_IMAGE_USAGE_STORAGE_BIT</b> to its usage flag.
				<br>
				<b>(main.c: 635)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">createImage(
	app, 
	800, 
	600, 
	app->swapchainImageFormat, 
	VK_IMAGE_TILING_OPTIMAL, 
	VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_STORAGE_BIT, 
	VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, 
	&app->rayTraceImage, 
	&app->rayTraceImageMemory
);
</code></pre>
				</div>
				<br>
        <h4><b>Acceleration Structure Setup</b></h4>
        <h6><b>Create Bottom Level Acceleration Structure</b></h6>
        Creating the bottom level acceleration structure defines the acceleration structure's configuration. We must specify the primitive count, index type, vertex count, and vertex format when creating the bottom level acceleration structure. 
        <br>
        <b>(main.c: 695)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkAccelerationStructureCreateGeometryTypeInfoKHR geometryInfos = {};
geometryInfos.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR;
geometryInfos.geometryType = VK_GEOMETRY_TYPE_TRIANGLES_KHR;
geometryInfos.maxPrimitiveCount = scene->attributes.num_face_num_verts;
geometryInfos.indexType = VK_INDEX_TYPE_UINT32;
geometryInfos.maxVertexCount = scene->attributes.num_vertices;
geometryInfos.vertexFormat = VK_FORMAT_R32G32B32_SFLOAT;
geometryInfos.allowsTransforms = VK_FALSE;
</code></pre>
				</div>
				<h6><b>Bind Bottom Level Acceleration Structure</b></h6>
				Now that we have the configuration of the acceleration structure, we need to bind it so we can build it using geometry from a vertex and index buffer.
				<h6><b>Build Bottom Level Acceleration Structure</b></h6>
				First, we need to get the device address of the vertex and index buffer.
				<br>
				<b>(main.c: 753)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkBufferDeviceAddressInfo vertexBufferDeviceAddressInfo = {};
vertexBufferDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
vertexBufferDeviceAddressInfo.buffer = app->vertexPositionBuffer;

VkDeviceAddress vertexBufferAddress = pvkGetBufferDeviceAddressKHR(app->logicalDevice, &vertexBufferDeviceAddressInfo);

VkDeviceOrHostAddressConstKHR vertexDeviceOrHostAddressConst = {};
vertexDeviceOrHostAddressConst.deviceAddress = vertexBufferAddress;

VkBufferDeviceAddressInfo indexBufferDeviceAddressInfo = {};
indexBufferDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
indexBufferDeviceAddressInfo.buffer = app->indexBuffer;

VkDeviceAddress indexBufferAddress = pvkGetBufferDeviceAddressKHR(app->logicalDevice, &indexBufferDeviceAddressInfo);

VkDeviceOrHostAddressConstKHR indexDeviceOrHostAddressConst = {};
indexDeviceOrHostAddressConst.deviceAddress = indexBufferAddress;
</code></pre>
				</div>
				Now we can set the acceleration structure geometry to use the addresses.
				<br>
				<b>(main.c: 771)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkAccelerationStructureGeometryTrianglesDataKHR trianglesData = {};
trianglesData.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR;
trianglesData.pNext = NULL;
trianglesData.vertexFormat = VK_FORMAT_R32G32B32_SFLOAT;
trianglesData.vertexData = vertexDeviceOrHostAddressConst;
trianglesData.vertexStride = sizeof(float) * 3;
trianglesData.indexType = VK_INDEX_TYPE_UINT32;
trianglesData.indexData = indexDeviceOrHostAddressConst;
trianglesData.transformData = (VkDeviceOrHostAddressConstKHR){}; 
</code></pre>
				</div>
				Building an acceleration structures requires extra memory; we need to create a scratch buffer and provide its device address to the geometry information structure.
				<br>
				<b>(main.c: 818)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkBuffer scratchBuffer;
VkDeviceMemory scratchBufferMemory;
createBuffer(app, scratchSize, VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &scratchBuffer, &scratchBufferMemory);

VkBufferDeviceAddressInfo scratchBufferDeviceAddressInfo = {};
scratchBufferDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
scratchBufferDeviceAddressInfo.buffer = scratchBuffer;

VkDeviceAddress scratchBufferAddress = pvkGetBufferDeviceAddressKHR(app->logicalDevice, &scratchBufferDeviceAddressInfo);

VkDeviceOrHostAddressKHR scratchDeviceOrHostAddress = {};
scratchDeviceOrHostAddress.deviceAddress = scratchBufferAddress;

const VkAccelerationStructureBuildGeometryInfoKHR* buildGeometryInfo = &(VkAccelerationStructureBuildGeometryInfoKHR){
  .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
  .pNext = NULL,
  .type = VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR,
  .flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  .update = VK_FALSE,
  .srcAccelerationStructure = VK_NULL_HANDLE,
  .dstAccelerationStructure = app->bottomLevelAccelerationStructure,
  .geometryArrayOfPointers = VK_TRUE,
  .geometryCount = 1,
  .ppGeometries = geometries,
  .scratchData = scratchDeviceOrHostAddress
};

const VkAccelerationStructureBuildOffsetInfoKHR* buildOffsetInfoPtr = &(VkAccelerationStructureBuildOffsetInfoKHR){
  .primitiveCount = scene->attributes.num_face_num_verts,
  .primitiveOffset = 0,
  .firstVertex = 0,
  .transformOffset = 0  
};
const VkAccelerationStructureBuildOffsetInfoKHR** buildOffsetInfos = &buildOffsetInfoPtr;
</code></pre>
				</div>
				After setting up the all the structures, we need to actually build the acceleration structure; we pass the build acceleration structure command to the command buffer. 				
				<br>
				<b>(main.c: 853)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo);
pvkCmdBuildAccelerationStructureKHR(commandBuffer, 1, buildGeometryInfo, buildOffsetInfos);
vkEndCommandBuffer(commandBuffer);
</code></pre>
				</div>
				<h6><b>Create, Bind, and Build Top Level Acceleration Structure</b></h6>
        Now that we have a working bottom level acceleration structure, we need to create a top level acceleration structure to hold instances on the bottom level acceleration structure. The process is basically the same as creating, binding, and building the bottom level acceleration structure with just a few small changes.

        <br><br>
        Just like setting up the bottom level acceleration structure, we first need to create the top level acceleration structure. The only notable difference is to use the <b>VK_GEOMETRY_TYPE_INSTANCES_KHR</b> flag instead of the <b>VK_GEOMETRY_TYPE_TRIANGLES_KHR</b> when describing the acceleration structure's geometry type.
        <br>
        <b>(main.c: 879)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkAccelerationStructureCreateGeometryTypeInfoKHR geometryInfos = {};
geometryInfos.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_GEOMETRY_TYPE_INFO_KHR;
geometryInfos.geometryType = VK_GEOMETRY_TYPE_INSTANCES_KHR;
geometryInfos.maxPrimitiveCount = 1;
geometryInfos.allowsTransforms = VK_TRUE;
</code></pre>
        </div>
        Next, we need to bind the acceleration structure so it can be built.
        <br><br>
        After binding the acceleration structure, we need to build the acceleration structure using the bottom level acceleration structure we previously built. Instead of getting the device address of the vertex and index buffer, we need to get the address of the bottom level acceleration structure.
        <br>
        <b>(main.c: 931)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkAccelerationStructureDeviceAddressInfoKHR accelerationStructureDeviceAddressInfo = {};
accelerationStructureDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR;
accelerationStructureDeviceAddressInfo.accelerationStructure = app->bottomLevelAccelerationStructure;

VkDeviceAddress accelerationStructureDeviceAddress = pvkGetAccelerationStructureDeviceAddressKHR(app->logicalDevice, &accelerationStructureDeviceAddressInfo);
</code></pre>
        </div>
        Now we can use that device address to propagate the acceleration structure geometry.
        <br>
        <b>(main.c: 937)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkAccelerationStructureInstanceKHR geometryInstance = {};
geometryInstance.transform = transformMatrix;
geometryInstance.instanceCustomIndex = 0;
geometryInstance.mask = 0xFF;
geometryInstance.instanceShaderBindingTableRecordOffset = 0;
geometryInstance.flags = VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR;
geometryInstance.accelerationStructureReference = accelerationStructureDeviceAddress;
</code></pre>
        </div>
        Since the top level acceleration structure can hold many instances of the same bottom level acceleration structure, we need to create instance buffer to hold all the instances that will be used for ray intersection. Since we only want a single instance of the bottom level acceleration structure, our instance buffer will only hold the instance that we just described.
        <br>
        <b>(main.c: 947)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkBuffer geometryInstanceStagingBuffer;
VkDeviceMemory geometryInstanceStagingBufferMemory;
createBuffer(app, geometryInstanceBufferSize, VK_BUFFER_USAGE_TRANSFER_SRC_BIT, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT, &geometryInstanceStagingBuffer, &geometryInstanceStagingBufferMemory);

void* geometryInstanceData;
vkMapMemory(app->logicalDevice, geometryInstanceStagingBufferMemory, 0, geometryInstanceBufferSize, 0, &geometryInstanceData);
memcpy(geometryInstanceData, &geometryInstance, geometryInstanceBufferSize);
vkUnmapMemory(app->logicalDevice, geometryInstanceStagingBufferMemory);

VkBuffer geometryInstanceBuffer;
VkDeviceMemory geometryInstanceBufferMemory;
createBuffer(app, geometryInstanceBufferSize, VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &geometryInstanceBuffer, &geometryInstanceBufferMemory);  

copyBuffer(app, geometryInstanceStagingBuffer, geometryInstanceBuffer, geometryInstanceBufferSize);

vkDestroyBuffer(app->logicalDevice, geometryInstanceStagingBuffer, NULL);
vkFreeMemory(app->logicalDevice, geometryInstanceStagingBufferMemory, NULL);

VkBufferDeviceAddressInfo geometryInstanceBufferDeviceAddressInfo = {};
geometryInstanceBufferDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
geometryInstanceBufferDeviceAddressInfo.buffer = geometryInstanceBuffer;

VkDeviceAddress geometryInstanceBufferAddress = pvkGetBufferDeviceAddressKHR(app->logicalDevice, &geometryInstanceBufferDeviceAddressInfo);

VkDeviceOrHostAddressConstKHR geometryInstanceDeviceOrHostAddressConst = {};
geometryInstanceDeviceOrHostAddressConst.deviceAddress = geometryInstanceBufferAddress;

VkAccelerationStructureGeometryInstancesDataKHR instancesData = {};
instancesData.sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR;
instancesData.pNext = NULL;
instancesData.arrayOfPointers = VK_FALSE;
instancesData.data = geometryInstanceDeviceOrHostAddressConst; 
</code></pre>
        </div>
        We also need to create a scratch buffer that will be used when building the acceleration structure
        <br>
        <b>(main.c: 1004)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkBuffer scratchBuffer;
VkDeviceMemory scratchBufferMemory;
createBuffer(app, scratchSize, VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR | VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT, &scratchBuffer, &scratchBufferMemory);

VkBufferDeviceAddressInfo scratchBufferDeviceAddressInfo = {};
scratchBufferDeviceAddressInfo.sType = VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO;
scratchBufferDeviceAddressInfo.buffer = scratchBuffer;

VkDeviceAddress scratchBufferAddress = pvkGetBufferDeviceAddressKHR(app->logicalDevice, &scratchBufferDeviceAddressInfo);

VkDeviceOrHostAddressKHR scratchDeviceOrHostAddress = {};
scratchDeviceOrHostAddress.deviceAddress = scratchBufferAddress;

const VkAccelerationStructureBuildGeometryInfoKHR* buildGeometryInfo = &(VkAccelerationStructureBuildGeometryInfoKHR){
  .sType = VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,
  .pNext = NULL,
  .type = VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR,
  .flags = VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR,
  .update = VK_FALSE,
  .srcAccelerationStructure = VK_NULL_HANDLE,
  .dstAccelerationStructure = app->topLevelAccelerationStructure,
  .geometryArrayOfPointers = VK_TRUE,
  .geometryCount = 1,
  .ppGeometries = geometries,
  .scratchData = scratchDeviceOrHostAddress
};

const VkAccelerationStructureBuildOffsetInfoKHR* buildOffsetInfoPtr = &(VkAccelerationStructureBuildOffsetInfoKHR){
  .primitiveCount = 1,
  .primitiveOffset = 0,
  .firstVertex = 0,
  .transformOffset = 0  
};
const VkAccelerationStructureBuildOffsetInfoKHR** buildOffsetInfos = &buildOffsetInfoPtr;
</code></pre>
        </div>
        With everything setup, we can finally build the top level acceleration structure
        <br>
        <b>(main.c: 1052)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">vkBeginCommandBuffer(commandBuffer, &commandBufferBeginInfo);
pvkCmdBuildAccelerationStructureKHR(commandBuffer, 1, buildGeometryInfo, buildOffsetInfos);
vkEndCommandBuffer(commandBuffer);
</code></pre>
        </div>
        <h4><b>Descriptor Setup</b></h4>
        <h6><b>Create Uniform Buffer</b></h6>
        We create a uniform buffer to hold the <b>camera</b> so we can pass the camera's data into the shaders.
        <h6><b>Create Descriptor Sets</b></h6>
        First we need to create the descriptor pools that the descriptor sets will be allocated from. In this case, we must set the descriptor pool sizes to match the amount of structures we are going to pass to the shaders.
        <br><br>
        In our case, we have the following structures:
        <ul>
          <li>World Geometry (Acceleration Structure)</li>
          <li>Ray Traced Image (Storage Image)</li>
          <li>Camera (Uniform Buffer)</li>
          <li>Vertex Index Buffer (Storage Buffer)</li>
          <li>Vertex Position Buffer (Storage Buffer)</li>
          <li>Material Index Buffer (Storage Buffer)</li>
          <li>Material Buffer (Storage Buffer)</li>
        </ul>
        So in total, we need to make the pool size large enough to contain, 1 acceleration structure, 1 storage image, 1 uniform buffer, and 4 storage buffers.
        <br>
        <b>(main.c: 1081)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkDescriptorPoolSize descriptorPoolSizes[4];
descriptorPoolSizes[0].type = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;
descriptorPoolSizes[0].descriptorCount = 1;

descriptorPoolSizes[1].type = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
descriptorPoolSizes[1].descriptorCount = 1;

descriptorPoolSizes[2].type = VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER;
descriptorPoolSizes[2].descriptorCount = 1;

descriptorPoolSizes[3].type = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
descriptorPoolSizes[3].descriptorCount = 4;

VkDescriptorPoolCreateInfo descriptorPoolCreateInfo = {};
descriptorPoolCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO;
descriptorPoolCreateInfo.poolSizeCount = 4;
descriptorPoolCreateInfo.pPoolSizes = descriptorPoolSizes;
descriptorPoolCreateInfo.maxSets = 2;

if (vkCreateDescriptorPool(app->logicalDevice, &descriptorPoolCreateInfo, NULL, &app->descriptorPool) == VK_SUCCESS) {
  printf("\033[22;32m%s\033[0m\n", "created descriptor pool");
}
</code></pre>
        </div>
        We are separating the structures that deal with materials into their own descriptor set. So we have 1 descriptor set that will hold the acceleration structure, ray traced image, camera, vertex index buffer, and vertex position buffer. The other descriptor set will hold the material index buffer and the material buffer.
        <br><br>
        Let's set up the first descriptor set. We first need to set up the descriptor set layout to indicate which structures will be accessed by which binding.
        <br>
        <b>(main.c: 1105)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkDescriptorSetLayoutBinding descriptorSetLayoutBindings[5];
descriptorSetLayoutBindings[0].binding = 0;
descriptorSetLayoutBindings[0].descriptorCount = 1;
descriptorSetLayoutBindings[0].descriptorType = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;
descriptorSetLayoutBindings[0].pImmutableSamplers = NULL;
descriptorSetLayoutBindings[0].stageFlags = VK_SHADER_STAGE_RAYGEN_BIT_KHR | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;

descriptorSetLayoutBindings[1].binding = 1;
descriptorSetLayoutBindings[1].descriptorCount = 1;
descriptorSetLayoutBindings[1].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_IMAGE;
descriptorSetLayoutBindings[1].pImmutableSamplers = NULL;
descriptorSetLayoutBindings[1].stageFlags = VK_SHADER_STAGE_RAYGEN_BIT_KHR | VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;

...

VkDescriptorSetLayoutCreateInfo descriptorSetLayoutCreateInfo = {};
descriptorSetLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO;
descriptorSetLayoutCreateInfo.bindingCount = 5;
descriptorSetLayoutCreateInfo.pBindings = descriptorSetLayoutBindings;

if (vkCreateDescriptorSetLayout(app->logicalDevice, &descriptorSetLayoutCreateInfo, NULL, &app->rayTraceDescriptorSetLayouts[0]) == VK_SUCCESS) {
  printf("\033[22;32m%s\033[0m\n", "created descriptor set layout");
}
</code></pre>
        </div>
        Now that we have the layout to the first descriptor set, we can update the descriptor sets with the addresses of the structures.
        <br>
        <b>(main.c: 1155)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkWriteDescriptorSet writeDescriptorSets[5];

VkWriteDescriptorSetAccelerationStructureKHR descriptorSetAccelerationStructure = {};
descriptorSetAccelerationStructure.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR;
descriptorSetAccelerationStructure.pNext = NULL;
descriptorSetAccelerationStructure.accelerationStructureCount = 1;
descriptorSetAccelerationStructure.pAccelerationStructures = &app->topLevelAccelerationStructure;  

writeDescriptorSets[0].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
writeDescriptorSets[0].pNext = &descriptorSetAccelerationStructure;
writeDescriptorSets[0].dstSet = app->rayTraceDescriptorSet;
writeDescriptorSets[0].dstBinding = 0;
writeDescriptorSets[0].dstArrayElement = 0;
writeDescriptorSets[0].descriptorCount = 1;
writeDescriptorSets[0].descriptorType = VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR;
writeDescriptorSets[0].pImageInfo = NULL;
writeDescriptorSets[0].pBufferInfo = NULL;
writeDescriptorSets[0].pTexelBufferView = NULL;

...

VkDescriptorBufferInfo vertexBufferInfo = {};
vertexBufferInfo.buffer = app->vertexPositionBuffer;
vertexBufferInfo.offset = 0;
vertexBufferInfo.range = VK_WHOLE_SIZE;

writeDescriptorSets[4].sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET;
writeDescriptorSets[4].pNext = NULL;
writeDescriptorSets[4].dstSet = app->rayTraceDescriptorSet;
writeDescriptorSets[4].dstBinding = 4;
writeDescriptorSets[4].dstArrayElement = 0;
writeDescriptorSets[4].descriptorCount = 1;
writeDescriptorSets[4].descriptorType = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
writeDescriptorSets[4].pImageInfo = NULL;
writeDescriptorSets[4].pBufferInfo = &vertexBufferInfo;
writeDescriptorSets[4].pTexelBufferView = NULL;

vkUpdateDescriptorSets(app->logicalDevice, 5, writeDescriptorSets, 0, NULL);
</code></pre>
        </div>
        We will also have the same process for the second descriptor set.
        <br><br>
        <h4><b>Ray Tracing Pipeline</b></h4>
        <h6><b>Create Ray Tracing Pipeline</b></h6>
        Our ray tracing pipeline uses the following 4 shaders: raytrace.rgen, raytrace.rmiss, raytrace_shadow.rmiss, and raytrace.rchit. First, the rays are generated with the raytrace.rgen shader stage which are then casted onto the acceleration structure. If the ray intersects geometry, the raytrace.rchit shader stage will handle the ray's payload. If the ray does not intersect any geometry, the raytrace.rchit shader stage will handle the ray's payload.
        <br><br>
        We load the shaders just like how we would load a vertex or fragment shader. The only difference is setting the shader stage info to the correct shader stage.
        <br>
        <b>(main.c: 1391)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkPipelineShaderStageCreateInfo rgenShaderStageInfo = {};
rgenShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
rgenShaderStageInfo.stage = VK_SHADER_STAGE_RAYGEN_BIT_KHR;
rgenShaderStageInfo.module = rgenShaderModule;
rgenShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo rmissShaderStageInfo = {};
rmissShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
rmissShaderStageInfo.stage = VK_SHADER_STAGE_MISS_BIT_KHR;
rmissShaderStageInfo.module = rmissShaderModule;
rmissShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo rmissShadowShaderStageInfo = {};
rmissShadowShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
rmissShadowShaderStageInfo.stage = VK_SHADER_STAGE_MISS_BIT_KHR;
rmissShadowShaderStageInfo.module = rmissShadowShaderModule;
rmissShadowShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo rchitShaderStageInfo = {};
rchitShaderStageInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
rchitShaderStageInfo.stage = VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR;
rchitShaderStageInfo.module = rchitShaderModule;
rchitShaderStageInfo.pName = "main";

VkPipelineShaderStageCreateInfo shaderStages[4] = {rgenShaderStageInfo, rmissShaderStageInfo, rmissShadowShaderStageInfo, rchitShaderStageInfo};
</code></pre>
        </div>
        We now create the shader groups to contain the previously described shader stages.
        <br>
        <b>(main.c: 1417)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkRayTracingShaderGroupCreateInfoKHR shaderGroupCreateInfos[4];
shaderGroupCreateInfos[0].sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
shaderGroupCreateInfos[0].pNext = NULL;
shaderGroupCreateInfos[0].type = VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR;
shaderGroupCreateInfos[0].generalShader = 0;
shaderGroupCreateInfos[0].closestHitShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[0].anyHitShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[0].intersectionShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[0].pShaderGroupCaptureReplayHandle = NULL;

...

shaderGroupCreateInfos[3].sType = VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR;
shaderGroupCreateInfos[3].pNext = NULL;
shaderGroupCreateInfos[3].type = VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR;
shaderGroupCreateInfos[3].generalShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[3].closestHitShader = 3;
shaderGroupCreateInfos[3].anyHitShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[3].intersectionShader = VK_SHADER_UNUSED_KHR;
shaderGroupCreateInfos[3].pShaderGroupCaptureReplayHandle = NULL;
</code></pre>
        </div>
        The pipeline layout can be created using the previously created descriptor set layouts.
        <br>
        <b>(main.c: 1454)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkPipelineLayoutCreateInfo pipelineLayoutCreateInfo = {};
pipelineLayoutCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;
pipelineLayoutCreateInfo.setLayoutCount = 2;
pipelineLayoutCreateInfo.pSetLayouts = app->rayTraceDescriptorSetLayouts;
pipelineLayoutCreateInfo.pushConstantRangeCount = 0;

if (vkCreatePipelineLayout(app->logicalDevice, &pipelineLayoutCreateInfo, NULL, &app->rayTracePipelineLayout) == VK_SUCCESS) {
  printf("created ray trace pipline layout\n");
}
</code></pre>
        </div>
        With all the structures we just defined, we can finally create the ray tracing pipeline!
        <br>
        <b>(main.c: 1464)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkPipelineLibraryCreateInfoKHR pipelineLibraryCreateInfo = {};
pipelineLibraryCreateInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR;
pipelineLibraryCreateInfo.pNext = NULL;
pipelineLibraryCreateInfo.libraryCount = 0;
pipelineLibraryCreateInfo.pLibraries = NULL;

VkRayTracingPipelineCreateInfoKHR rayPipelineCreateInfo = {};
rayPipelineCreateInfo.sType = VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR;
rayPipelineCreateInfo.pNext = NULL;
rayPipelineCreateInfo.flags = 0;
rayPipelineCreateInfo.stageCount = 4;
rayPipelineCreateInfo.pStages = shaderStages;
rayPipelineCreateInfo.groupCount = 4;
rayPipelineCreateInfo.pGroups = shaderGroupCreateInfos;
rayPipelineCreateInfo.maxRecursionDepth = 16;
rayPipelineCreateInfo.libraries = pipelineLibraryCreateInfo;
rayPipelineCreateInfo.pLibraryInterface = NULL;
rayPipelineCreateInfo.layout = app->rayTracePipelineLayout;
rayPipelineCreateInfo.basePipelineHandle = VK_NULL_HANDLE;
rayPipelineCreateInfo.basePipelineIndex = -1;

if (pvkCreateRayTracingPipelinesKHR(app->logicalDevice, VK_NULL_HANDLE, 1, &rayPipelineCreateInfo, NULL, &app->rayTracePipeline) == VK_SUCCESS) {
  printf("created ray trace pipeline\n");
}
</code></pre>
        </div>
        <h6><b>Create Shader Binding Table</b></h6>
        The shader binding table holds the handles of all the shaders and will be used to determine which shader should be executed. Since we have 4 shaders, 1 ray generation, 1 ray closest hit, and 2 ray miss, we must make sure that all the shader handles will fit within the shader binding table buffer.
        <br>
        <b>(main.c: 1511)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkDeviceSize shaderBindingTableSize = app->rayTracingProperties.shaderGroupHandleSize * 4;

app->shaderBindingTableBufferMemory;
createBuffer(app, shaderBindingTableSize, VK_BUFFER_USAGE_RAY_TRACING_BIT_KHR, VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT, &app->shaderBindingTableBuffer, &app->shaderBindingTableBufferMemory);

void* shaderHandleStorage = (void*)malloc(sizeof(uint8_t) * shaderBindingTableSize);
if (pvkGetRayTracingShaderGroupHandlesKHR(app->logicalDevice, app->rayTracePipeline, 0, 4, shaderBindingTableSize, shaderHandleStorage) == VK_SUCCESS) {
  printf("got ray tracing shader group handles\n");
}

void* data;
vkMapMemory(app->logicalDevice, app->shaderBindingTableBufferMemory, 0, shaderBindingTableSize, 0, &data);
for (int x = 0; x < 4; x++) {
  memcpy(data, (uint8_t*)shaderHandleStorage + x * app->rayTracingProperties.shaderGroupHandleSize, app->rayTracingProperties.shaderGroupHandleSize);
  data += app->rayTracingProperties.shaderGroupBaseAlignment;
}
vkUnmapMemory(app->logicalDevice, app->shaderBindingTableBufferMemory);

free(shaderHandleStorage);
</code></pre>
        </div>
        <h4><b>Command Buffers</b></h4>
        When tracing rays, we need to provide all the shader handle information. The first handle will be the ray generation shader which will be offset 0. The handles will be for the two ray miss shaders which will be offset 1. The last handle will be the ray closest hit shader which will be offset 3.
        <br>
        <b>(main.c: 1551)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">VkDeviceSize progSize = app->rayTracingProperties.shaderGroupBaseAlignment;
VkDeviceSize rayGenOffset = 0u * progSize;
VkDeviceSize missOffset = 1u * progSize;
VkDeviceSize hitGroupOffset = 3u * progSize;

VkDeviceSize sbtSize = progSize * (VkDeviceSize)4;

const VkStridedBufferRegionKHR rgenShaderBindingTable = {
  .buffer = app->shaderBindingTableBuffer,
  .offset = rayGenOffset,
  .stride = progSize,
  .size = sbtSize 
};

const VkStridedBufferRegionKHR rmissShaderBindingTable = {
  .buffer = app->shaderBindingTableBuffer,
  .offset = missOffset,
  .stride = progSize,
  .size = sbtSize 
};

const VkStridedBufferRegionKHR rchitShaderBindingTable = {
  .buffer = app->shaderBindingTableBuffer,
  .offset = hitGroupOffset,
  .stride = progSize,
  .size = sbtSize 
};
</code></pre>
        </div>
        Now we begin the command buffer. First, we need to add the commands to bind the pipeline and two descriptor sets we previously created.
        <br>
        <b>(main.c: 1588)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">if (vkBeginCommandBuffer(app->commandBuffers[x], &commandBufferBeginCreateInfo) == VK_SUCCESS) {
  printf("\033[22;32m%s%d\033[0m\n", "began recording command buffer for image #", x);
}
  
vkCmdBindPipeline(app->commandBuffers[x], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, app->rayTracePipeline);
vkCmdBindDescriptorSets(app->commandBuffers[x], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, app->rayTracePipelineLayout, 0, 1, &app->rayTraceDescriptorSet, 0, 0);
vkCmdBindDescriptorSets(app->commandBuffers[x], VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, app->rayTracePipelineLayout, 1, 1, &app->materialDescriptorSet, 0, 0);
</code></pre>
        </div>
        We add the command to trace the rays using the shader handle information and the ray dimensions 800x600.
        <br>
        <b>(main.c: 1596)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">pvkCmdTraceRaysKHR(app->commandBuffers[x], &rgenShaderBindingTable, &rmissShaderBindingTable, &rchitShaderBindingTable, &callableShaderBindingTable, 800, 600, 1);
</code></pre>
        </div>
        When the trace ray command is executed, a ray traced image will be produced. To have the image on the screen, we must copy the image to the swapchain for presentation. We have to set the pipeline barriers for both the ray traced and swapchain image. The ray traced image's new layout will be set to <b>VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL</b> while the swapchain image's new layout will be set to <b>VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL</b>.
        <br>
        <b>(main.c: 1598)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">{ 
  VkImageMemoryBarrier imageMemoryBarrier = {};
  imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  imageMemoryBarrier.pNext = NULL;
  imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_GENERAL;
  imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL;
  imageMemoryBarrier.image = app->rayTraceImage;
  imageMemoryBarrier.subresourceRange = subresourceRange;
  imageMemoryBarrier.srcAccessMask = 0;
  imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT;

  vkCmdPipelineBarrier(app->commandBuffers[x], VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, NULL, 0, NULL, 1, &imageMemoryBarrier);
}

{ 
  VkImageMemoryBarrier imageMemoryBarrier = {};
  imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;
  imageMemoryBarrier.pNext = NULL;
  imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_UNDEFINED;
  imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL;
  imageMemoryBarrier.image = app->swapchainImages[x];
  imageMemoryBarrier.subresourceRange = subresourceRange;
  imageMemoryBarrier.srcAccessMask = 0;
  imageMemoryBarrier.dstAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT;

  vkCmdPipelineBarrier(app->commandBuffers[x], VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, VK_PIPELINE_STAGE_ALL_COMMANDS_BIT, 0, 0, NULL, 0, NULL, 1, &imageMemoryBarrier);
}
</code></pre>
        </div>
        We add a command to copy the ray traced image to the swapchain.
        <br>
        <b>(main.c: 1627)</b>
        <div class="w3-card-4 w3-margin w3-white">
<pre><code style="font-size: 12px; white-space: pre-wrap;">{
  VkImageSubresourceLayers subresourceLayers = {};
  subresourceLayers.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  subresourceLayers.mipLevel = 0;
  subresourceLayers.baseArrayLayer = 0;
  subresourceLayers.layerCount = 1;

  VkOffset3D offset = {};
  offset.x = 0;
  offset.y = 0;
  offset.z = 0;

  VkExtent3D extent = {};
  extent.width = 800;
  extent.height = 600;
  extent.depth = 1;

  VkImageCopy imageCopy = {};
  imageCopy.srcSubresource = subresourceLayers;
  imageCopy.srcOffset = offset;
  imageCopy.dstSubresource = subresourceLayers;
  imageCopy.dstOffset = offset;
  imageCopy.extent = extent;

  vkCmdCopyImage(app->commandBuffers[x], app->rayTraceImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, app->swapchainImages[x], VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &imageCopy);
}
</code></pre>
        </div>
        Now that we have copied the ray traced image to the swapchain image, we set the swapchain image's new layout to <b>VK_IMAGE_LAYOUT_PRESENT_SRC_KHR</b> and end the command buffer.
        <br><br>
        <h4><b>Main Loop</b></h4>
        When compared to a "standard non-raytraced" application, there are no major differences when creating the synchronization objects or writing the main loop. When cleaning up the program, you must make sure to clean up all the new structures made from ray tracing (ex: acceleration structure, ray tracing pipeline, ray traced image, etc...).
      </p>
    </div>
  </div>
  <hr>
</div>

<div class="w3-col">
  <div class="w3-card-4 w3-margin w3-white">
    <div class="w3-container">
      <h2><b>Ray Query</b></h2>
      <h4><b>Work in Progress</b></h4>
    </div>
  </div>
  <hr>
</div>

</div><br>

</div>

</body>
</html>
